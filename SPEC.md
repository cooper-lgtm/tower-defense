# SPEC

## 从旧项目中的提取和理解
旧项目中, 几条游戏规则的设定很有意思. 金币, 积分, 防御塔, 无限模式, 以及怪物的行动轨迹、数值等
旧项目中:
金币: 起始金币+每波奖励+击杀奖励+卖塔返还. 并且按照波数指数递增, 越到后面钱越多. 卖塔固定返还50%
积分: 每次攻击到才会有积分
防御塔: 五座防御塔, 
波次: 波次增加, 怪物属性增加
怪物行进路线: 不会穿过墙体, 并且要求一定有路

## 新版本提取的规则
- 基础经济（金币）
  -起始金币 initialGold=70，初始生命 initialLife=20（见 grid.initialGold/initialLife）。
  -每波基础奖励 waveRewardBase=6，按 waveRewardGrowth=1.15 指数递增：第 n 波基础奖励 ≈ 6 * 1.15^(n-1)。
  -击杀奖励：killRewardMultiplier=1，每只怪的 reward 乘以该系数（怪物表内有 reward）。
  -卖塔返还：sellRefundRate=0.5，即返还原价的 50%。

- 积分
  -计分唯一发生在塔攻击命中时：tower.ts 里每次攻击对每个受击敌人计算 dealt = min(max(0, 伤害-护甲), 剩余血量)，然后加分 floor(sqrt(dealt))。溅射/多目标会对每个实际受伤的敌人分别累加。

- 防御塔数值
  -CANNON：伤害 22，攻速 1.1，射程 3.5，群攻半径 0.6，成本 [12,18,28,44,68]
  -LMG：伤害 10，攻速 3.2，射程 4.5，成本 [10,16,24,36,52]
  -HMG：伤害 40，攻速 0.85，射程 2.8，群攻半径 0.4，成本 [16,24,36,52,72]
  -LASER：伤害 55，攻速 0.65，射程 4.2，穿透 2，成本 [20,32,48,70,96]
  -FREEZE：伤害 8，攻速 1，射程 4，减速 50% 持续 2.5s，成本 [14,22,32,48,66]
  -WALL：伤害/攻速/射程 0，纯阻挡，成本 [6,9,12,16,22]

- 波次设计
  -固定波前 6 波示例：①8x NORMAL；②10x NORMAL + 6x FAST；③10x NORMAL + 10x FAST + 3x TANK；④6x SHIELD + 12x FAST；⑤4x BRUISER + 6x TANK + 8x FAST；⑥含 BOSS：1x BOSS + 6x BRUISER + 10x TANK + 12x FAST。
  -后续使用生成器：每波最多 40 只，类型权重 NORMAL 2 / FAST 1.6 / TANK 1.1 / SHIELD 1 / BRUISER 0.9 / BOSS 0.1，难度增长 difficultyGrowth=0.12。

- 怪物路线
  -路径规划：用 4 邻接 A*（aStar.ts）在栅格上从入口到出口寻路。
  -阻挡定义：网格把静态障碍、不可建造区、预置塔以及现有/待建塔都记为阻挡（grid.ts 的 blockedWithOccupancy）。墙壁和防御塔都占用格子。
  -刷怪/行进：生成波次时预计算一条 basePath；每只怪跟着这条离散路径前进，不做物理碰撞，因此不会“穿过”占用格子。
  -建塔校验：Game.tryBuildTower 先检查新格子是否建造后仍有从入口到出口的路径；对存活敌人逐个重算路径，若任何一只被堵死则建造失败并提示。
  -动态改路：建塔成功后会为当前存活的敌人调用 retargetPath 让它们走新路径，因此建塔会改变怪物行进路线，但不会把它们卡死。


## 目标与范围
- 通过前端塔防游戏与后端服务联动，提供账号、关卡配置下发、成绩上传与榜单查询能力。
- 客户端被视为不可信：服务端负责最终的成绩记录与榜单维护。

## 核心规则与需求
- 身份
  - 支持注册/登录，返回 Bearer JWT。
  - `guest` 为保留名，可免密登录，用于试玩，不参与榜单。
- 关卡
  - 关卡配置存储于服务端（`app/data/levels/*.json`），字段含 `version` 和计算出的 `hash`。关卡的“权威版本”只在服务端保存（endless.json），带有 version 和服务端算出的 hash。
  - 客户端请求关卡时返回完整配置 + `version` + `hash`，用于后续提交校验。客户端每次想开一局时，先 GET /api/levels/{id} 拿最新的配置 + version + hash，用它来驱动本局游戏。上传成绩时客户端要把刚才拿到的 version/hash原样带回，服务端会再算一遍当前关卡的 hash 做对比，只有匹配才入库。
- 成绩上传
  - 仅登录用户（非 guest）可上传。
  - 提交体需携带：`level_id`、`level_version`、`level_hash`、`score`、`wave`、`time_ms`、`life_left`。
  - 服务端依据当前关卡文件校验 `level_version`、`level_hash` 一致后才入库。
  - 同步更新榜单：同一用户仅保留该关卡的最高分，分数相同时取耗时更短的记录。
- 榜单
  - 排序仍然是按成绩（同分看耗时），长度由 TD_LEADERBOARD_SIZE 控制，支持 limit 1~100。
  - 提供 HTTP 查询与 WebSocket 定期推送两种访问方式。

## 边界条件与取舍
- 客户端不可信：服务端只校验版本/hash，未做运行时反作弊（如操作轨迹校验），因而仍可伪造高分；通过“只保留最高分”“时间更短优先”弱化重复提交影响。
- 数据一致性：成绩与榜单更新在同一请求内完成，Redis 不可用时回退内存榜单（进程级，非持久化）。
- 性能/开发取舍：使用同步 SQLAlchemy Session + FastAPI 依赖注入，便于测试和覆盖率；榜单以 Redis ZSET 实现，满足小规模实时需求。
- 注册简单化：未强制邮箱/验证码，便于快速体验；密码仅做 bcrypt 哈希。
